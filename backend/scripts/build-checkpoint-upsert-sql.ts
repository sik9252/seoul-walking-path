import crypto from "node:crypto";
import fs from "node:fs";
import path from "node:path";

type CheckpointRow = {
  courseId: string;
  checkpointOrder: number;
  rawName: string;
  canonicalName: string;
  lat: number | null;
  lng: number | null;
  confidenceScore: number;
  needsReview: boolean;
  source: "manual_fix" | "auto_geocode";
};

type GeocodedPayload = {
  checkpoints: CheckpointRow[];
};

const rootDir = path.resolve(__dirname, "..");
const inputPath = path.join(rootDir, "data/generated/course-checkpoints.geocoded.json");
const outputPath = path.join(rootDir, "data/generated/course-checkpoints.upsert.sql");

function toUuid(seed: string): string {
  const hex = crypto.createHash("sha1").update(seed).digest("hex").slice(0, 32);
  return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20, 32)}`;
}

function escapeSqlLiteral(input: string): string {
  return input.replace(/'/g, "''");
}

function toSqlNumber(input: number | null): string {
  if (input === null || !Number.isFinite(input)) return "null";
  return String(input);
}

function main() {
  if (!fs.existsSync(inputPath)) {
    throw new Error(`Missing geocoded checkpoint file: ${inputPath}`);
  }

  const payload = JSON.parse(fs.readFileSync(inputPath, "utf8")) as GeocodedPayload;
  const rows = payload.checkpoints ?? [];

  if (rows.length === 0) {
    throw new Error("No checkpoint rows found.");
  }

  const values = rows
    .map((row) => {
      const id = toUuid(`${row.courseId}:${row.checkpointOrder}:${row.canonicalName}`);
      return `('${id}', '${escapeSqlLiteral(row.courseId)}', ${row.checkpointOrder}, '${escapeSqlLiteral(
        row.rawName,
      )}', '${escapeSqlLiteral(row.canonicalName)}', ${toSqlNumber(row.lat)}, ${toSqlNumber(
        row.lng,
      )}, ${row.confidenceScore}, ${row.needsReview ? "true" : "false"}, '${row.source}')`;
    })
    .join(",\n");

  const sql = `-- generated by scripts/build-checkpoint-upsert-sql.ts
insert into course_checkpoints (
  id,
  course_id,
  checkpoint_order,
  raw_name,
  canonical_name,
  lat,
  lng,
  confidence_score,
  needs_review,
  source
)
values
${values}
on conflict (course_id, checkpoint_order)
do update set
  raw_name = excluded.raw_name,
  canonical_name = excluded.canonical_name,
  lat = excluded.lat,
  lng = excluded.lng,
  confidence_score = excluded.confidence_score,
  needs_review = excluded.needs_review,
  source = excluded.source,
  updated_at = now();
`;

  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, sql, "utf8");
  console.log(`Wrote SQL upsert for ${rows.length} checkpoints -> ${outputPath}`);
}

main();
